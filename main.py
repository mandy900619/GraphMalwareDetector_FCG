from utils import parse_args
from utils import write_to_file
import os
import r2pipe
from func_timeout import func_set_timeout
import func_timeout
import networkx as nx
import pickle
import torch
import torch.nn as nn
import torchvision.models as models
from torch_geometric.utils.convert import from_networkx
from graphSAGE import SAGE

@func_set_timeout(3600)

def extract_fcg_radare2(input: str):
    print("Radare2 feature extraction...")
    filename = os.path.basename(input)
    r2 = r2pipe.open(input)
    r2.cmd("aaaa")
    command = 'agCd'
    dotString = r2.cmd(command)
    G = nx.DiGraph()
    label = {} # key: node addr, value: function name
    function_opcode_mapping = {} # key: node addr, value: list of opcodes
    if len(dotString.split('\n')) < 9:
        print(f'No function in this file: {filename}\n')
        return
    for lines in dotString.split('\n'):
        tmp = []
        for words in lines.split():
            if words[0] == '"':
                words = words.replace('"', '')
            tmp.append(words)
        try:
            if tmp[1][1] == 'l': # is a node
                func = tmp[1][7:]
                func = func.replace('"', '')
                label[tmp[0]] = func
                piCommand = "pif @" + tmp[0] + "~[0]"
                Instructions = r2.cmd(piCommand)
                opcode_list = []
                if Instructions:
                    opcode_list = Instructions.split('\n')
                function_opcode_mapping[func] = opcode_list
        except:
            pass

    for lines in dotString.split('\n'):
        tmp = []
        for words in lines.split():
            if words[0] == '"':
                words = words.replace('"', '')
            tmp.append(words)
        try:
            if tmp[1] == '->':
                G.add_edge(label[tmp[0]], label[tmp[2]])
        except:
            pass

    for node in G.nodes(): # add x attribute to each node
        G.nodes[node]['x'] = function_opcode_mapping[node]
    
    r2.cmd("quit")

    return G

def MyEmbedding(vocab_size, embedding_dim):
    torch.manual_seed(5)
    embedding = nn.Embedding(vocab_size, embedding_dim)
    return embedding


def instruction_module(graph, opcode_set):
    print("Instruction module...")
    vocab_size = len(opcode_set)
    embedding_dim = 100
    embedding_modle = MyEmbedding(vocab_size, embedding_dim)
    embedding = {}
    embedding_mean_x = {}
    try:
        for node in graph.nodes():
            function_embedding = []
            for opcode in graph.nodes[node]["x"]:
                if opcode in opcode_set:
                    function_embedding.append(opcode_set.index(opcode))
            embedding[node] = embedding_modle(torch.LongTensor(function_embedding))
            embedding_mean_x[node] = torch.mean(embedding[node], dim=0)
            del graph.nodes[node]["x"]
            graph.nodes[node]["x"] = embedding_mean_x[node]
    except Exception as e:
        print(f"Exception: {e}")
        return

    for node in graph.nodes():
        graph.nodes[node]['x'] = torch.nan_to_num(graph.nodes[node]['x'], nan=0.0)
    torch_data = from_networkx(graph)


    return torch_data

def predict(data):
    print("Predict...")
    #load the hole model
    model = torch.load('./models/graphSAGE_model_Hash_graph2.pt', map_location=torch.device('cpu'))

    print(model)

    model.eval()
    #predict
    batch = torch.zeros(data[0].x.shape[0], dtype=torch.long)
    output = model(data[0].x, data[0].edge_index, batch)

    return output




def main(args):
    result = [-1]

    try:
        fcg = extract_fcg_radare2(args.input_path)

    except func_timeout.exceptions.FunctionTimedOut:
        print(f"Timeout in radare2: {args.input_path}")

    with open(args.opcode_set, "rb") as f:
        opcode_set = pickle.load(f)
        f.close()
    
    embedding_data = instruction_module(fcg,  opcode_set)
    result = predict(embedding_data)
    probs = torch.softmax(result, dim=1)
    probs = probs.tolist()[0]
    print(probs)

    write_to_file(args.input_path, args.output_path, probs)

if __name__=='__main__':
    args = parse_args()
    main(args)